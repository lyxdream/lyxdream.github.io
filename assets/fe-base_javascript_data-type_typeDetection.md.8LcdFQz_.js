import{_ as t,o as e,c as a,R as o}from"./chunks/framework.iNKEMQtI.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"fe-base/javascript/data-type/typeDetection.md","filePath":"fe-base/javascript/data-type/typeDetection.md","lastUpdated":1701769291000}'),p={name:"fe-base/javascript/data-type/typeDetection.md"},c=o('<h2 id="类型检测" tabindex="-1">类型检测 <a class="header-anchor" href="#类型检测" aria-label="Permalink to &quot;类型检测&quot;">​</a></h2><p>判断变量的类型</p><h3 id="常见的判断变量的类型有四种" tabindex="-1">常见的判断变量的类型有四种 <a class="header-anchor" href="#常见的判断变量的类型有四种" aria-label="Permalink to &quot;常见的判断变量的类型有四种&quot;">​</a></h3><p>1、typeof 不能判断变量的类型 typeof [] typeof {}</p><p>2、constructor 可以找到这个变量是通过谁构造数来的 构造函数</p><p>3、instanceof 判断谁是谁的实例 <em>proto</em></p><p>4、Object.prototype.toString.call() 可以判断类型，不能判断谁是谁的实例</p><p>具体详细内容敬请期待。。。。</p><p>typeof只能判断基本数据类型，对象类型同一判断为object无法细化，并且null也会被判断为object</p><p>instanceof用于从原型角度判断某个值的类型，如果该值的原型链上有该属性则返回true，但是无法判断基本类型值；或者说instanceof用于判断某个值是否为目标类的实例或子实例。</p><p>contructor没用过判断数据类型，盲猜是根据obj.contructor === Obj来判断该值是否为父类实例</p><p>Object.prototype.toString.call()非常有用Object.prototype.toString 方法会根据这个对象的[[class]]内部属性，返回由 &quot;[object &quot; 和 class 和 &quot;]&quot; 三个部分组成的字符串。</p>',12),r=[c];function n(s,i,_,l,d,f){return e(),a("div",null,r)}const b=t(p,[["render",n]]);export{h as __pageData,b as default};

import{_ as s,o as a,c as i,R as n,aa as e,ab as l}from"./chunks/framework.iNKEMQtI.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"fe-base/node/index.md","filePath":"fe-base/node/index.md","lastUpdated":1701769291000}'),p={name:"fe-base/node/index.md"},t=n('<h3 id="node基本概念" tabindex="-1">Node基本概念 <a class="header-anchor" href="#node基本概念" aria-label="Permalink to &quot;Node基本概念&quot;">​</a></h3><h2 id="一-node是什么" tabindex="-1">一.Node是什么? <a class="header-anchor" href="#一-node是什么" aria-label="Permalink to &quot;一.Node是什么?&quot;">​</a></h2><p>Node.js是一个基于 Chrome V8 引擎的JavaScript运行环境(runtime),Node不是一门语言是让js运行在后端的运行时,并且不包括javascript全集,因为在服务端中不包含DOM和BOM,Node也提供了一些新的模块例如http,fs模块等。Node.js 使用了事件驱动、非阻塞式 I/O 的模型，使其轻量又高效并且Node.js 的包管理器 npm，是全球最大的开源库生态系统。事件驱动与非阻塞IO后面我们会一一介绍。到此我们已经对node有了简单的概念。</p><h2 id="二-node解决了哪些问题" tabindex="-1">二.Node解决了哪些问题? <a class="header-anchor" href="#二-node解决了哪些问题" aria-label="Permalink to &quot;二.Node解决了哪些问题?&quot;">​</a></h2><p>Node在处理高并发,I/O密集场景有明显的性能优势</p><ul><li>高并发,是指在同一时间并发访问服务器</li><li>I/O密集指的是文件操作、网络操作、数据库,相对的有CPU密集,CPU密集指的是逻辑处理运算、压缩、解压、加密、解密</li></ul><blockquote><p>Web主要场景就是接收客户端的请求读取静态资源和渲染界面,所以Node非常适合Web应用的开发。</p></blockquote><h2 id="三-js单线程" tabindex="-1">三.JS单线程 <a class="header-anchor" href="#三-js单线程" aria-label="Permalink to &quot;三.JS单线程&quot;">​</a></h2><p>javascript在最初设计时设计成了单线程,为什么不是多线程呢？如果多个线程同时操作DOM那岂不会很混乱？这里所谓的单线程指的是主线程是单线程的,所以在Node中主线程依旧是单线程的。</p><ul><li>单线程特点是节约了内存,并且不需要在切换执行上下文</li><li>而且单线程不需要管锁的问题.</li></ul><h2 id="四-同步异步和阻塞非阻塞" tabindex="-1">四.同步异步和阻塞非阻塞 <a class="header-anchor" href="#四-同步异步和阻塞非阻塞" aria-label="Permalink to &quot;四.同步异步和阻塞非阻塞&quot;">​</a></h2><p><img src="'+e+'" alt="同步异步和阻塞非阻塞"></p><h2 id="五-node中的event-loop" tabindex="-1">五.Node中的Event Loop <a class="header-anchor" href="#五-node中的event-loop" aria-label="Permalink to &quot;五.Node中的Event Loop&quot;">​</a></h2><p><img src="'+l+`" alt="同步异步和阻塞非阻塞"></p><ul><li>1.我们写的js代码会交给v8引擎进行处理</li><li>2.代码中可能会调用nodeApi,node会交给libuv库处理</li><li>3.libuv通过阻塞i/o和多线程实现了异步io</li><li>4.通过事件驱动的方式,将结果放到事件队列中,最终交给我们的应用。</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    本阶段执行已经被 </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() 和 </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() 的调度回调函数。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   ┌───────────────────────────┐</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">┌─</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│           timers          │ </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  └─────────────┬─────────────┘</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   执行延迟到下一个循环迭代的 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">O</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 回调。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  ┌─────────────┴─────────────┐</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  │     pending callbacks     │</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  └─────────────┬─────────────┘</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   仅系统内部使用。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  ┌─────────────┴─────────────┐</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  │       idle, prepare       │</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  └─────────────┬─────────────┘      </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  检索新的I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">O事件;执行与 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">O相关的回调  ┌───────────────┐</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  ┌─────────────┴─────────────┐      │   </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">incoming</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:   │</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  │           poll            │</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">─────┤  connections, │</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  └─────────────┬─────────────┘      │   data, etc.  │</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setImmediate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() 回调函数在这里执行。  └───────────────┘</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  ┌─────────────┴─────────────┐      </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  │           check           │</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  └─────────────┬─────────────┘</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  一些关闭的回调函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│  ┌─────────────┴─────────────┐</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">└──┤      close callbacks      │</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   └───────────────────────────┘</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><blockquote><p>这里每一个阶段都对应一个事件队列,当event loop执行到某个阶段时会将当前阶段对应的队列依次执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段</p></blockquote><blockquote><p>process.nextTick() 从技术上讲不是事件循环的一部分.</p></blockquote><h2 id="六-node中全局对象" tabindex="-1">六.Node中全局对象 <a class="header-anchor" href="#六-node中全局对象" aria-label="Permalink to &quot;六.Node中全局对象&quot;">​</a></h2><ul><li>Buffer</li><li>process</li><li>setInterval,setTimeout,setImmediate</li><li>console</li><li>queueMicrotask</li></ul><h2 id="七-node中的模块" tabindex="-1">七.node中的模块 <a class="header-anchor" href="#七-node中的模块" aria-label="Permalink to &quot;七.node中的模块&quot;">​</a></h2><ul><li>__dirname</li><li>__filename</li><li>exports</li><li>module</li><li>require()</li></ul>`,22),h=[t];function r(k,d,o,E,c,b){return a(),i("div",null,h)}const g=s(p,[["render",r]]);export{m as __pageData,g as default};
